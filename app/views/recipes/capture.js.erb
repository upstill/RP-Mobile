// capture.js.erb
/* This file is invoked by the RecipePower bookmarklet. It injects an iframe 
   onto the page, with content generated by recipePower. At various points 
   (e.g., to resize, or to close) it
   sends a message back up here via a message-passing scheme from ba-postmessage. */
(function() {
    var ifr = document.createElement("iframe");
    // ifr.style.margin="1em";
    ifr.style.width=document.body.clientWidth+"px"; // "100%";
    // ifr.style.height = "auto";
    ifr.style['z-index'] = 100;
    ifr.style.position = "fixed";
	ifr.style.top = "0";
	ifr.style.padding = "0";
	ifr.style.margin = "0";
	ifr.style.display = 'none';
    ifr.id = "recipePower-iframe";
    ifr.src = "<%= @url %>";
	// set the width of the frame to that of the enclosing document
	ifr.style.width = window.outerWidth;
	/*
	if (ifr.attachEvent){
	    ifr.attachEvent("onload", ifrOnload);
	} else {
	    ifr.onload = ifrOnload;
	}
	*/
    document.body.appendChild(ifr);
})();

/*
function ifrOnload() {
	var ifr = this;
/* We would love to encapsulate the window content so we can move the top out of the way
   of the injected content, but it doesn't seem to work, at least on htmldog.com
	var capsule = document.getElementById("RecipePowerInjectedEncapsulation");
	if(!capsule) { 
	  capsule = wrapWithoutCloning(ifr);
	} 
* /
	/* We go back to the server for the dimensions of the iframe content, running
		returned Javascript to set the size appropriately * /
	get_resize(ifr.attributes["src"].nodeValue);
}
*/

function execute_resize(dims) {
	var height = dims.height;
	
	/* Set the top margin of the encapsulation to clear the iframe
	var capsule = document.getElementById("RecipePowerInjectedEncapsulation");
	var mgn = height+"px 0px 0px 0px";
	capsule.style.margin=mgn;
	*/
	
	var ifr = document.getElementById("recipePower-iframe");
	ifr.height=height;
	ifr.style.display = 'block';
}

/* Called when the X to cancel the dialog is clicked */
function retire_iframe() {
	var iframe = document.getElementById("recipePower-iframe");
	if(iframe) {
		iframe.style.display = 'none';
		iframe.parentNode.removeChild(iframe);		
	}
	// Sadly obsolete: unwrapWithoutCloning();
	var script = document.getElementById("recipePower-injector");
	if(script) {
		script.parentNode.removeChild(script);
	}
}

/* Encapsulate the body content of the page with a div wrapper.
  NB: doesn't pertain until we figure out how to do this correctly (doesn't
	work for htmldog.com) 
function wrapWithoutCloning(omitted) {
	var body = document.body;
	var wrapper = document.createElement('div'); 
	wrapper.id = "RecipePowerInjectedEncapsulation";
	// wrapper.style = body.style;
    wrapper.style.position = "absolute";
    wrapper.style.width = document.body.clientWidth; // "auto";
    wrapper.style.height = "auto";
	body.insertBefore(wrapper, body.firstChild );
	var child;
	while ((child = body.childNodes[1]) && (child != omitted)) {
		body.removeChild(child);
		wrapper.appendChild(child);
	}
	return wrapper;
}

/* Remove the previously-injected wrapper * /
function unwrapWithoutCloning() {
	var body = document.body;
	var wrapper = document.getElementById('RecipePowerInjectedEncapsulation');
	var child;
	while(child = wrapper.childNodes[0]) {
		wrapper.removeChild(child);
		body.insertBefore(child, wrapper);
	}
	body.removeChild(wrapper);
}
*/

// Define receive-message handler from ba-postmessage.js
(function($){
  // '$:nomunge'; // Used by YUI compressor.
  
  // A few vars used in non-awesome browsers.
  var interval_id,
    last_hash,
    cache_bust = 1,
    
    // A var used in awesome browsers.
    rm_callback,
    
    // A few convenient shortcuts.
    window = this,
    FALSE = !1,
    
    // Reused internal strings.
    postMessage = 'postMessage',
    addEventListener = 'addEventListener',
    
    p_receiveMessage,
    
    // I couldn't get window.postMessage to actually work in Opera 9.64!
    has_postMessage = window[postMessage] // XXX && !$.browser.opera;

  
  $.receiveMessage = p_receiveMessage = function( callback, source_origin, delay ) {
    if ( has_postMessage ) {
      // Since the browser supports window.postMessage, the callback will be
      // bound to the actual event associated with window.postMessage.
      
      if ( callback ) {
        // Unbind an existing callback if it exists.
        rm_callback && p_receiveMessage();
        
        // Bind the callback. A reference to the callback is stored for ease of
        // unbinding.
        rm_callback = function(e) {
          if ( ( typeof source_origin === 'string' && e.origin !== source_origin )
             || ( (typeof source_origin === 'function') && source_origin( e.origin ) === FALSE ) ) {
            return FALSE;
          }
          callback( e );
        };
      }
      
      if ( window[addEventListener] ) {
        window[ callback ? addEventListener : 'removeEventListener' ]( 'message', rm_callback, FALSE );
      } else {
        window[ callback ? 'attachEvent' : 'detachEvent' ]( 'onmessage', rm_callback );
      }
      
    } else {
      // Since the browser sucks, a polling loop will be started, and the
      // callback will be called whenever the location.hash changes.
      
      interval_id && clearInterval( interval_id );
      interval_id = null;
      
      if ( callback ) {
        delay = typeof source_origin === 'number'
          ? source_origin
          : typeof delay === 'number'
            ? delay
            : 100;
        
        interval_id = setInterval(function(){
          var hash = document.location.hash,
            re = /^#?\d+&/;
          if ( hash !== last_hash && re.test( hash ) ) {
            last_hash = hash;
            callback({ data: hash.replace( re, '' ) });
          }
        }, delay );
      }
    }
  };

})(window);

window.receiveMessage( function(evt) {
	
	// By convention, messages arrive as a query string which gets turned
	// into an object whose 'call' parameter denotes a function to call, 
	// passing in the object carrying the rest of the parameters.
	var params = evt.data.split('&');
	var data = {}, call = "";
	var re = /([^=]*)=(.*)$/;
	for(var i = 0, len = params.length; i < len; ++i) {
	    var param = params[i];
	    var parts = re.exec(param);
	    if(parts[1] == "call") {
		   call = parts[2];
	    } else {
			data[parts[1]] = parts[2];
		}
	}
	// Now we have a data array and a function to call
	if(typeof window[call] === 'function') {
		window[call](data);
	}
}, "http://<%= Rails.env.development? ? "localhost:5000" : "www.recipepower.com" %>" );
