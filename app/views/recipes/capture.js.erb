// capture.js.erb
/* This file is invoked by the RecipePower bookmarklet. It injects an iframe 
   onto the page, with content generated by recipePower. At various points 
   (e.g., to resize, or to close) it
   sends a message back up here via a message-passing scheme from ba-postmessage. */
(function() {
	var ifr = document.createElement("iframe");
	// ifr.style.margin="1em";
	ifr.style.width = document.body.clientWidth + "px"; // "100%";
	// ifr.style.height = "auto";
	ifr.style['z-index'] = 100;
	ifr.style.position = "fixed";
	ifr.style.top = "0";
	ifr.style.padding = "0";
	ifr.style.margin = "0";
	ifr.style.display = 'none';
	ifr.id = "recipePower-iframe";
	ifr.src = "<%= @url %>";
	// set the width of the frame to that of the enclosing document
	ifr.style.width = window.outerWidth;
	/*
	if (ifr.attachEvent){
	    ifr.attachEvent("onload", ifrOnload);
	} else {
	    ifr.onload = ifrOnload;
	}
	*/
    document.body.appendChild(ifr);
    
	/* Define the style for highlighting images for picking */
	var css = 'img.recipePower-highlight { border:#ffaa66 8px solid; }',
	    head = document.getElementsByTagName('head')[0],
	    style = document.createElement('style');

	style.type = 'text/css';
	if(style.styleSheet){
	    style.styleSheet.cssText = css;
	}else{
	    style.appendChild(document.createTextNode(css));
	}
	head.appendChild(style);
})();

/* Called when the X to cancel the dialog is clicked */
function retire_iframe() {
	var iframe = document.getElementById("recipePower-iframe");
	if(iframe) {
		iframe.style.display = 'none';
		iframe.parentNode.removeChild(iframe);		
	}
	// Sadly obsolete: unwrapWithoutCloning();
	var script = document.getElementById("recipePower-injector");
	if(script) {
		script.parentNode.removeChild(script);
	}
}

/*
function ifrOnload() {
	var ifr = this;
/* We would love to encapsulate the window content so we can move the top out of the way
   of the injected content, but it doesn't seem to work, at least on htmldog.com
	var capsule = document.getElementById("RecipePowerInjectedEncapsulation");
	if(!capsule) { 
	  capsule = wrapWithoutCloning(ifr);
	} 
* /
	/* We go back to the server for the dimensions of the iframe content, running
		returned Javascript to set the size appropriately * /
	get_resize(ifr.attributes["src"].nodeValue);
}
*/

function execute_resize(dims) {
	var height = dims.height;
	
	/* Set the top margin of the encapsulation to clear the iframe
	var capsule = document.getElementById("RecipePowerInjectedEncapsulation");
	var mgn = height+"px 0px 0px 0px";
	capsule.style.margin=mgn;
	*/
	
	var ifr = document.getElementById("recipePower-iframe");
	ifr.height=height;
	ifr.style.display = 'block';
}

/* Encapsulate the body content of the page with a div wrapper.
  NB: doesn't pertain until we figure out how to do this correctly (doesn't
	work for htmldog.com) 
function wrapWithoutCloning(omitted) {
	var body = document.body;
	var wrapper = document.createElement('div'); 
	wrapper.id = "RecipePowerInjectedEncapsulation";
	// wrapper.style = body.style;
    wrapper.style.position = "absolute";
    wrapper.style.width = document.body.clientWidth; // "auto";
    wrapper.style.height = "auto";
	body.insertBefore(wrapper, body.firstChild );
	var child;
	while ((child = body.childNodes[1]) && (child != omitted)) {
		body.removeChild(child);
		wrapper.appendChild(child);
	}
	return wrapper;
}

/* Remove the previously-injected wrapper * /
function unwrapWithoutCloning() {
	var body = document.body;
	var wrapper = document.getElementById('RecipePowerInjectedEncapsulation');
	var child;
	while(child = wrapper.childNodes[0]) {
		wrapper.removeChild(child);
		body.insertBefore(child, wrapper);
	}
	body.removeChild(wrapper);
}
*/

// Define mouse-hover highlighting for images
(function() {
  var prev;

  function attch(img) {
		if (img.addEventListener) {
			img.addEventListener('mouseover', mouseon, false);
			img.addEventListener('mouseout', mouseoff, false);
			img.addEventListener('click', imgclick, false);
		} else if (img.attachEvent) {
			img.attachEvent('onmouseover', function(e) {
				return mouseon(e || window.event);
			});
			img.attachEvent('onmouseout', function(e) {
				return mouseoff(e || window.event);
			});
			img.attachEvent('onclick', function(e) {
				return imgclick(e || window.event);
			});
		} else {
			img.onmouseover = mouseon;
			img.onmouseout = mouseoff;
			img.onclick = imgclick;
		}	
	}

  var ix, img, imgs = document.getElementsByTagName('img');
	for (ix = 0; img = imgs[ix]; ix++) {
		attch(img);
	}

  function mouseon(event) {
    if (event.target === document.body ||
        (prev && prev === event.target)) {
      return;
    }
    if (prev) {
      prev.className = prev.className.replace(/\brecipePower-highlight\b/, '');
      prev = undefined;
    }
    if (event.target) {
      prev = event.target;
      prev.className += " recipePower-highlight";
    }
  }

  function mouseoff(event) {
    if (event.target) {
      event.target.className = event.target.className.replace(/\brecipePower-highlight\b/, '');
    }
  }

  function imgclick(event) { // Handle a click on an image by sending its url to the iframe
		var img;
		debugger;
		if(img = event.target) {
			var src = img.src;
			var iframe = document.getElementById('recipePower-iframe')
			window.postMessage(
				{ url: img.src,
					call: "replaceImg"
				}, "http://<%= Rails.env.development? ? "localhost:5000" : "www.recipepower.com" %>", iframe.contentWindow);
      event.preventDefault();
      event.stopPropagation();
		}
	}
})();

// Define receive-message handler from ba-postmessage.js
(function($){
  // '$:nomunge'; // Used by YUI compressor.
  
  // A few vars used in non-awesome browsers.
  var interval_id,
    last_hash,
    cache_bust = 1,
    
    // A var used in awesome browsers.
    rm_callback,
    
    // A few convenient shortcuts.
    window = this,
    FALSE = !1,
    
    // Reused internal strings.
    postMessage = 'postMessage',
    addEventListener = 'addEventListener',
    
    p_receiveMessage,
    
    // I couldn't get window.postMessage to actually work in Opera 9.64!
    has_postMessage = window[postMessage] // XXX && !$.browser.opera;
  
  $.buildParam = function(parameters){
	  var qs = "";
	  for(var key in parameters) {
	    var value = parameters[key];
	    qs += encodeURIComponent(key) + "=" + encodeURIComponent(value) + "&";
	  }
	  if (qs.length > 0) {
	    qs = qs.substring(0, qs.length-1); //chop off last "&"
	  }
	  return qs;
	}
	
  $.postMessage = function( message, target_url, target ) {
    if ( !target_url ) { return; }
    
    // Serialize the message if not a string. Note that this is the only real
    // jQuery dependency for this script. If removed, this script could be
    // written as very basic JavaScript.
debugger;
    message = typeof message === 'string' ? message : $.buildParam( message );
    
    // Default to parent if unspecified.
    target = target || parent;
    
    if ( has_postMessage ) {
      // The browser supports window.postMessage, so call it with a targetOrigin
      // set appropriately, based on the target_url parameter.
      target[postMessage]( message, target_url.replace( /([^:]+:\/\/[^\/]+).*/, '$1' ) );
      
    } else if ( target_url ) {
      // The browser does not support window.postMessage, so set the location
      // of the target to target_url#message. A bit ugly, but it works! A cache
      // bust parameter is added to ensure that repeat messages trigger the
      // callback.
      target.location = target_url.replace( /#.*$/, '' ) + '#' + (+new Date) + (cache_bust++) + '&' + message;
    }
  };

  // Function for cracking param string
	$.ptq = function(q) {
		/* parse the message */
		/* semicolons are nonstandard but we accept them */
		var x = q.replace(/;/g, '&').split('&'), i, name, t;
		/* q changes from string version of query to object */
		for (q={}, i=0; i<x.length; i++) {
			t = x[i].split('=', 2);
			name = unescape(t[0]);
			if (!q[name])
				q[name] = [];
			if (t.length > 1) {
				q[name][q[name].length] = unescape(t[1]);
			} else
			/* next two lines are nonstandard */
				q[name][q[name].length] = true;
		}
		return q;
	}
  
  $.receiveMessage = p_receiveMessage = function( callback, source_origin, delay ) {
    if ( has_postMessage ) {
      // Since the browser supports window.postMessage, the callback will be
      // bound to the actual event associated with window.postMessage.
      
      if ( callback ) {
        // Unbind an existing callback if it exists.
        rm_callback && p_receiveMessage();
        
        // Bind the callback. A reference to the callback is stored for ease of
        // unbinding.
        rm_callback = function(e) {
          if ( ( typeof source_origin === 'string' && e.origin !== source_origin )
             || ( (typeof source_origin === 'function') && source_origin( e.origin ) === FALSE ) ) {
            return FALSE;
          }
          callback( e );
        };
      }
      
      if ( window[addEventListener] ) {
        window[ callback ? addEventListener : 'removeEventListener' ]( 'message', rm_callback, FALSE );
      } else {
        window[ callback ? 'attachEvent' : 'detachEvent' ]( 'onmessage', rm_callback );
      }
      
    } else {
      // Since the browser sucks, a polling loop will be started, and the
      // callback will be called whenever the location.hash changes.
      
      interval_id && clearInterval( interval_id );
      interval_id = null;
      
      if ( callback ) {
        delay = typeof source_origin === 'number'
          ? source_origin
          : typeof delay === 'number'
            ? delay
            : 100;
        
        interval_id = setInterval(function(){
          var hash = document.location.hash,
            re = /^#?\d+&/;
          if ( hash !== last_hash && re.test( hash ) ) {
            last_hash = hash;
            callback({ data: hash.replace( re, '' ) });
          }
        }, delay );
      }
    }
  };

})(window);

window.receiveMessage( function(evt) {
	
	// By convention, messages arrive as a query string which gets turned
	// into an object whose 'call' parameter denotes a function to call, 
	// passing in the object carrying the rest of the parameters.
	// Parse the data string as a conventional set of queryparams
	var data = window.ptq(evt.data);
	// Now we have a data array and a function to call
	var call = data.call;
	debugger;
	if(call && (typeof window[call] === 'function')) {
		window[call](data);
	}
}, "http://<%= Rails.env.development? ? "localhost:5000" : "www.recipepower.com" %>" );
