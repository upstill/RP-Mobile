/* This file is invoked by the RecipePower bookmarklet. */
// capture.js.erb
(function() {
    var ifr = document.createElement("iframe");
    // ifr.style.margin="1em";
    ifr.style.width=document.body.clientWidth+"px"; // "100%";
    // ifr.style.height = "auto";
    ifr.style['z-index'] = 100;
    ifr.style.position = "fixed";
	ifr.style.top = "0";
	ifr.style.padding = "0";
	ifr.style.margin = "0";
	ifr.style.display = 'none';
    ifr.id = "recipePower-iframe";
    ifr.src = "<%= @url %>";
	// set the width of the frame to that of the enclosing document
	ifr.style.width = window.outerWidth;
	if (ifr.attachEvent){
	    ifr.attachEvent("onload", ifrOnload);
	} else {
	    ifr.onload = ifrOnload;
	}
    document.body.appendChild(ifr);
})();

function ifrOnload() {
	var ifr = this;
/* We would love to encapsulate the window content so we can move the top out of the way
   of the injected content, but it doesn't seem to work, at least on htmldog.com
	var capsule = document.getElementById("RecipePowerInjectedEncapsulation");
	if(!capsule) { 
	  capsule = wrapWithoutCloning(ifr);
	} 
*/
	/* We go back to the server for the dimensions of the iframe content, running
		returned Javascript to set the size appropriately */
	get_resize(ifr.attributes["src"].nodeValue);
}

function get_resize(uri) {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "http://localhost:5000/iframe/create.js?callback=execute_resize&url="+encodeURI(uri);
    script.id = "recipePower-loadJSONP";
    document.body.appendChild(script);
  }

function execute_resize(dims) {
	
	var height = dims.height;
	/*
	var capsule = document.getElementById("RecipePowerInjectedEncapsulation");
	var mgn = height+"px 0px 0px 0px";
	capsule.style.margin=mgn;
	*/
	
	var ifr = document.getElementById("recipePower-iframe");
	ifr.height=height;
	ifr.style.display = 'block';
	
	var s = document.getElementById("recipePower-loadJSONP");
	s.parentNode.removeChild(s);
}

/* This callback will be invoked by the javascript returned by the server, above */
function save_link_complete(data) {
  if(data.status == "success") {
    set_status("<h3>Yay!! Success</h3>"); // "<%# escape_javascript(render("shared/saved")) %>");
  } else {
    set_status("<h3>Boo! Failure</h3>"); // "<%# escape_javascript(render("shared/error")) %>");
  }
  retire_iframe();
}

function set_status(content) {
  alert(content); // jNotify(content); // document.getElementById("recipepower-status").innerHTML = content;
}

// Inject the container into the current document
function inject_iframe(ifr, area, modeless) {
  // First, remove any lingering style or script elements on the page
  // $('link.RecipePowerInjectedStyle').remove();
  // Inject our styles
  // $('<link href="http://localhost:5000/assets/foreign/dialog.css?body=1" media="screen" rel="stylesheet" type="text/css" id="RecipePowerInjectedStyle"/>').appendTo('head');
	// Find the dialog within the iframe (first and only node of type element)
	// var dlog = ifr.contentDocument.body.childNodes[0];
	var dlog = document.body.childNodes[0];
	while(dlog && dlog.nodeType != 1) {
			dlog = dlog.nextSibling;
		}
	dlog.style.width = capsule.clientWidth;
	/// close_iframe("recipePower-iframe");
	/// Now the page is ready to receive the code, prepended to the page
	/// We extract the dialog div from what may be a whole page
	/// Ensure that all scripts are loaded
	/// Run after-load functions
	/// We get and execute the onload function for the dialog
	var onload = dlog.attributes["onload"];
	if (onload && (typeof window[onload] === 'function')) {
		window[onload](dlog);
	}
	
	/// Cancel will remove the dialog and confirm null effect to user
	var cancelBtn = document.getElementById("recipePowerCancelBtn");
	if(cancelBtn) {
		cancelBtn.onclick = retire_iframe;
	}
	return dlog.offsetHeight;
	/// $('input.cancel', dlog).click( modeless ? cancelModelessDialog : cancelModalDialog );
	/// Forms submissions that expect JSON structured data will be handled here:
	/// $('form.json', dlog).submit( dlog, submitDialogForJSON );
	/// var dlgheight = $(dlog).outerHeight();
	/// $('#RecipePowerInjectedEncapsulation').css("marginTop", dlgheight)
}

/* Encapsulate the body content of the page with a div wrapper */
function wrapWithoutCloning(omitted) {
	var body = document.body;
	var wrapper = document.createElement('div'); 
	wrapper.id = "RecipePowerInjectedEncapsulation";
	// wrapper.style = body.style;
    wrapper.style.position = "absolute";
	debugger;
    wrapper.style.width = document.body.clientWidth; // "auto";
    wrapper.style.height = "auto";
	body.insertBefore(wrapper, body.firstChild );
	var child;
	while ((child = body.childNodes[1]) && (child != omitted)) {
		body.removeChild(child);
		wrapper.appendChild(child);
	}
	return wrapper;
}

/* Remove the previously-injected wrapper */
function unwrapWithoutCloning() {
	var body = document.body;
	var wrapper = document.getElementById('RecipePowerInjectedEncapsulation');
	var child;
	while(child = wrapper.childNodes[0]) {
		wrapper.removeChild(child);
		body.insertBefore(child, wrapper);
	}
	body.removeChild(wrapper);
}

// Define receive-message handler from ba-postmessage.js
(function($){
  // '$:nomunge'; // Used by YUI compressor.
  
  // A few vars used in non-awesome browsers.
  var interval_id,
    last_hash,
    cache_bust = 1,
    
    // A var used in awesome browsers.
    rm_callback,
    
    // A few convenient shortcuts.
    window = this,
    FALSE = !1,
    
    // Reused internal strings.
    postMessage = 'postMessage',
    addEventListener = 'addEventListener',
    
    p_receiveMessage,
    
    // I couldn't get window.postMessage to actually work in Opera 9.64!
    has_postMessage = window[postMessage] // XXX && !$.browser.opera;

  
  $.receiveMessage = p_receiveMessage = function( callback, source_origin, delay ) {
    if ( has_postMessage ) {
      // Since the browser supports window.postMessage, the callback will be
      // bound to the actual event associated with window.postMessage.
      
      if ( callback ) {
        // Unbind an existing callback if it exists.
        rm_callback && p_receiveMessage();
        
        // Bind the callback. A reference to the callback is stored for ease of
        // unbinding.
        rm_callback = function(e) {
	debugger;
          if ( ( typeof source_origin === 'string' && e.origin !== source_origin )
             || ( (typeof source_origin === 'function') && source_origin( e.origin ) === FALSE ) ) {
            return FALSE;
          }
          callback( e );
        };
      }
      
      if ( window[addEventListener] ) {
        window[ callback ? addEventListener : 'removeEventListener' ]( 'message', rm_callback, FALSE );
      } else {
        window[ callback ? 'attachEvent' : 'detachEvent' ]( 'onmessage', rm_callback );
      }
      
    } else {
      // Since the browser sucks, a polling loop will be started, and the
      // callback will be called whenever the location.hash changes.
      
      interval_id && clearInterval( interval_id );
      interval_id = null;
      
      if ( callback ) {
        delay = typeof source_origin === 'number'
          ? source_origin
          : typeof delay === 'number'
            ? delay
            : 100;
        
        interval_id = setInterval(function(){
          var hash = document.location.hash,
            re = /^#?\d+&/;
          if ( hash !== last_hash && re.test( hash ) ) {
            last_hash = hash;
            callback({ data: hash.replace( re, '' ) });
          }
        }, delay );
      }
    }
  };

})(window);

window.receiveMessage( function(evt) {
	var data = evt.data;
	debugger;
}, "http://<%= Rails.env.development? ? "localhost:5000" : "www.recipepower.com" %>" );
